# **abort() with Core Dump and Debugging Using Core Dump**
---

## **1️⃣ How `abort()` Generates a Core Dump**
A **core dump** is a file that contains a snapshot of a program's memory at the moment it crashes.  
When `abort()` is called, it sends **`SIGABRT`**, which by default:
- **Terminates the program**
- **Generates a core dump** (if enabled)

### **🔹 Steps for Core Dump Generation**
1. **Enable core dumps** (if disabled by system limits)
2. **Call `abort()`** in the program
3. **Analyze the core dump using `gdb`**

---

## **2️⃣ Checking and Enabling Core Dumps**
### **🔹 Check Core Dump Size Limit**
By default, Linux may restrict core dumps. To check the current limit:
```sh
ulimit -c
```
✅ **Output (if disabled)**
```
0
```
This means core dumps are **disabled**.

### **🔹 Enable Core Dumps**
To allow core dumps:
```sh
ulimit -c unlimited
```
✅ **Verify Again:**
```sh
ulimit -c
```
Now it should show:
```
unlimited
```

---

## **3️⃣ Example: `abort()` Producing a Core Dump**
Create a simple C program that calls `abort()`.

### **🔹 C Code:**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("Before abort()\n");
    abort();  // Generates SIGABRT and core dump
    printf("This will never execute\n");
    return 0;
}
```

### **🔹 Compile & Run:**
```sh
gcc -o test_abort test_abort.c
./test_abort
```

✅ **Output (If core dump is enabled)**
```
Before abort()
Aborted (core dumped)
```

---

## **4️⃣ Locating the Core Dump File**
The core dump file is usually generated in the **current directory** or `/var/core/`.

Find it with:
```sh
ls -lh core*
```
or
```sh
find / -name "core*" 2>/dev/null
```

### **Changing Core Dump File Name**
By default, it’s named **`core`**.  
You can configure core dumps with:
```sh
echo "core.%e.%p" | sudo tee /proc/sys/kernel/core_pattern
```
- `%e` → executable name  
- `%p` → process ID  

For example, a program `test_abort` might generate:
```
core.test_abort.12345
```

---

## **5️⃣ Analyzing Core Dump with GDB**
### **🔹 Load Core Dump in GDB**
```sh
gdb ./test_abort core
```
or, if named differently:
```sh
gdb ./test_abort core.test_abort.12345
```

### **🔹 Example GDB Output**
```
Core was generated by `./test_abort'.
Program terminated with signal SIGABRT, Aborted.
#0  0x00007f2a0a6127bb in raise () from /lib64/libc.so.6
```

### **🔹 Find the Crash Point**
Inside `gdb`, run:
```sh
bt
```
✅ **Output (Backtrace of function calls)**
```
#0  0x00007f2a0a6127bb in raise () from /lib64/libc.so.6
#1  0x00007f2a0a6138b5 in abort () from /lib64/libc.so.6
#2  0x000000000040113a in main () at test_abort.c:6
```
- `#2` shows **where** `abort()` was called (`test_abort.c:6`).

### **🔹 Inspect Variables at Crash**
```sh
frame 2
info locals
```

---

## **6️⃣ Core Dump Use Cases**
| Scenario | Purpose |
|----------|---------|
| **Debugging Crashes** | Find where the crash happened and inspect memory |
| **Post-Mortem Debugging** | Analyze a dead process later (e.g., on production servers) |
| **Segmentation Faults (`SIGSEGV`)** | Find invalid memory access issues |
| **Assertion Failures** | Debug failed assertions (`assert()`) |

---

## **7️⃣ Preventing Core Dumps**
If you **don’t** want core dumps:
```sh
ulimit -c 0
```
or disable core dumps permanently:
```sh
echo "* hard core 0" | sudo tee -a /etc/security/limits.conf
```

---

## **🔟 Summary**
✔ `abort()` calls **SIGABRT**, which generates a **core dump** (if enabled).  
✔ **Enable core dumps** using `ulimit -c unlimited`.  
✔ **Analyze core dumps** using `gdb` (`bt`, `info locals`).  
✔ Useful for **post-mortem debugging** in production environments.  
✔ **Disable core dumps** if not needed (`ulimit -c 0`).  

🚀 **Need more debugging techniques? Ask me!**
